"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.put = exports.post = exports.patch = exports.get = exports.default = exports.createAccessToken = exports._delete = void 0;
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _axios = _interopRequireDefault(require("axios"));
var _config = require("../config");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; } /* eslint-disable no-throw-literal */
const pjson = require('../../package.json');
function buildResponse(config, response) {
  if (config.csv) {
    return buildCsvResponse(response);
  }
  return buildJsonResponse(response);
}
function buildCsvResponse(_x) {
  return _buildCsvResponse.apply(this, arguments);
}
function _buildCsvResponse() {
  _buildCsvResponse = _asyncToGenerator(function* (response) {
    const txt = yield response.text();
    const csv = Buffer.from(txt);
    return {
      status: response.status,
      csv
    };
  });
  return _buildCsvResponse.apply(this, arguments);
}
function buildJsonResponse(response) {
  return response.text().then(text => {
    const data = !text ? {} : JSON.parse(text);
    const headers = getResponseHeaders(response);
    return {
      status: response.status,
      json: data,
      headers
    };
  });
}
function getRequestHeaders(config, request, authHeader, idempotencyKey) {
  let headers = _objectSpread(_objectSpread({}, config.headers), {}, {
    Authorization: authHeader,
    'Cache-Control': 'no-cache',
    pragma: 'no-cache',
    'user-agent': `checkout-sdk-node/${pjson.version}`
  });
  if (request && request.headers) {
    headers = _objectSpread(_objectSpread({}, headers), request.headers);
  }
  if (!config.formData) {
    headers['Content-Type'] = config.csv ? 'text/csv' : 'application/json';
  }
  if (idempotencyKey !== undefined) {
    headers['Cko-Idempotency-Key'] = idempotencyKey;
  }
  return headers;
}
function getResponseHeaders(response) {
  // Return CKO response headers when available

  if (_config.REQUEST_ID_HEADER in response.headers.raw()) {
    const requestId = response.headers.raw()[_config.REQUEST_ID_HEADER] || response.headers.raw()['request-id'];
    const version = response.headers.raw()[_config.API_VERSION_HEADER] || response.headers.raw().version;
    return {
      'cko-request-id': requestId ? requestId[0] : '',
      'cko-version': version ? version[0] : ''
    };
  }
  return {};
}
function getResponseAxiosHeaders(response) {
  // Return CKO response headers when available

  if (_config.REQUEST_ID_HEADER in response.headers) {
    const requestId = response.headers[_config.REQUEST_ID_HEADER] || response.headers['request-id'];
    const version = response.headers[_config.API_VERSION_HEADER] || response.headers.version;
    return {
      'cko-request-id': requestId ? requestId[0] : '',
      'cko-version': version ? version[0] : ''
    };
  }
  return {};
}
function buildAxiosResponse(config, response) {
  if (config.csv) {
    return {
      status: response.status,
      csv: Buffer.from(response.data)
    };
  }
  return {
    status: response.status,
    json: response.data,
    headers: getResponseAxiosHeaders(response)
  };
}

// For 'no body' response, replace with empty object
const bodyParser = rsp => rsp.text().then(text => text ? JSON.parse(text) : {});
const isTokenExpired = (tokenExpiry, currentTimestamp) => tokenExpiry < currentTimestamp;
const createAccessToken = exports.createAccessToken = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (config, httpClient, body) {
    const requestBody = body || {
      grant_type: 'client_credentials',
      client_id: config.client,
      client_secret: config.secret,
      scope: config.scope.join(' ')
    };
    let access;
    switch (httpClient) {
      case 'axios':
        access = yield (0, _axios.default)({
          url: config.host.includes('sandbox') ? _config.SANDBOX_ACCESS_URL : _config.LIVE_ACCESS_URL,
          method: 'post',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'application/json'
          },
          data: new URLSearchParams(requestBody),
          timeout: config.timeout,
          httpsAgent: config.agent
        }).catch(error => {
          if (error.response) {
            throw {
              status: error.response.status,
              json: error.toJSON()
            };
          } else if (error.request) {
            throw {
              request: error.request,
              json: error.toJSON()
            };
          } else {
            throw {
              message: error.message,
              json: error.toJSON()
            };
          }
        }).then(response => ({
          status: response.status,
          json: response.data
        }));
        return access;
      default:
        access = yield (0, _nodeFetch.default)(config.host.includes('sandbox') ? _config.SANDBOX_ACCESS_URL : _config.LIVE_ACCESS_URL, {
          method: 'post',
          timeout: config.timeout,
          agent: config.agent,
          body: new URLSearchParams(requestBody),
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'application/json'
          }
        });
        if (!access.ok) {
          const json = bodyParser(access);
          throw {
            status: access.status,
            json
          };
        }
        return access.text().then(text => {
          const data = text ? JSON.parse(text) : {};
          return {
            status: access.status,
            json: data
          };
        });
    }
  });
  return function createAccessToken(_x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

// eslint-disable-next-line consistent-return
const httpRequest = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* (httpClient, method, path, config, auth, request, idempotencyKey) {
    let authHeader = null;
    if (auth) {
      authHeader = auth;
    } else if (config.client) {
      // TODO Refactor OAuth credentials request

      // For NAS
      // If an access tokens exists, and it's not expired re-use it
      if (config.access && !isTokenExpired(config.access.expires, new Date())) {
        authHeader = `${config.access.type} ${config.access.token}`;
      } else {
        const access = yield createAccessToken(config, httpClient);
        authHeader = `${access.json.token_type} ${access.json.access_token}`;

        // eslint-disable-next-line no-param-reassign
        config.access = {
          token: access.json.access_token,
          type: access.json.token_type,
          scope: access.json.scope,
          expires: new Date(new Date().getTime() + access.json.expires_in)
        };
      }
    }
    const headers = getRequestHeaders(config, request, authHeader, idempotencyKey);
    let response;
    switch (httpClient) {
      case 'axios':
        response = yield (0, _axios.default)({
          url: path,
          method,
          headers,
          data: config.formData ? request : JSON.stringify(request),
          timeout: config.timeout,
          httpsAgent: config.agent
        }).catch(error => {
          if (error.response) {
            throw {
              status: error.response.status,
              json: error.toJSON()
            };
          } else if (error.request) {
            throw {
              request: error.request,
              json: error.toJSON()
            };
          } else {
            throw {
              message: error.message,
              json: error.toJSON()
            };
          }
        }).then(res => buildAxiosResponse(config, res));
        return response;
      default:
        response = yield (0, _nodeFetch.default)(path, {
          method,
          timeout: config.timeout,
          agent: config.agent,
          body: config.formData ? request : JSON.stringify(request),
          headers
        });
        if (!response.ok) {
          const json = bodyParser(response);
          throw {
            status: response.status,
            json
          };
        }
        return buildResponse(config, response);
    }
  });
  return function httpRequest(_x5, _x6, _x7, _x8, _x9, _x10, _x11) {
    return _ref2.apply(this, arguments);
  };
}();
const get = exports.get = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* (httpClient, path, config, auth) {
    return httpRequest(httpClient, 'get', path, config, auth);
  });
  return function get(_x12, _x13, _x14, _x15) {
    return _ref3.apply(this, arguments);
  };
}();
const post = exports.post = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(function* (httpClient, path, config, auth, request, idempotencyKey) {
    return httpRequest(httpClient, 'post', path, config, auth, request, idempotencyKey);
  });
  return function post(_x16, _x17, _x18, _x19, _x20, _x21) {
    return _ref4.apply(this, arguments);
  };
}();
const patch = exports.patch = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator(function* (httpClient, path, config, auth, request) {
    return httpRequest(httpClient, 'patch', path, config, auth, request);
  });
  return function patch(_x22, _x23, _x24, _x25, _x26) {
    return _ref5.apply(this, arguments);
  };
}();
const put = exports.put = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(function* (httpClient, path, config, auth, request) {
    return httpRequest(httpClient, 'put', path, config, auth, request);
  });
  return function put(_x27, _x28, _x29, _x30, _x31) {
    return _ref6.apply(this, arguments);
  };
}();
const _delete = exports._delete = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(function* (httpClient, path, config, auth) {
    return httpRequest(httpClient, 'delete', path, config, auth);
  });
  return function _delete(_x32, _x33, _x34, _x35) {
    return _ref7.apply(this, arguments);
  };
}();
var _default = exports.default = createAccessToken;
//# sourceMappingURL=http.js.map